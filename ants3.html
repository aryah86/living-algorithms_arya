<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<title>Ant Foraging With Solid Pale Yellow Obstacles</title>
<style>
    body { margin:0; overflow:hidden; background:#111; }
    canvas { display:block; }
</style>
</head>
<body>
<canvas id="c"></canvas>

<script>
// ===============================
// CANVAS SETUP
// ===============================
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");
canvas.width = innerWidth;
canvas.height = innerHeight;

addEventListener("resize", () => {
    canvas.width = innerWidth;
    canvas.height = innerHeight;
    walls.length = 0;
    createWalls();
});

// ===============================
// WORLD VARIABLES
// ===============================
const ANT_COUNT = 150;
const ants = [];
const foods = [];
const pheromone = [];

const gridSize = 10;
const cols = Math.ceil(canvas.width / gridSize);
const rows = Math.ceil(canvas.height / gridSize);

for (let x = 0; x < cols; x++) {
    pheromone[x] = [];
    for (let y = 0; y < rows; y++) pheromone[x][y] = 0;
}

// ===============================
// CURVED WALLS â€” converted to collision segments
// ===============================
const walls = [];
const wallSegments = []; // For collision detection

function createWalls() {
    const Y = "#e8e3a3";

    walls.push({
        cx: canvas.width * 0.35,
        cy: canvas.height * 0.28,
        radius: 140,
        thickness: 30,
        start: 0.2 * Math.PI,
        end: 1.35 * Math.PI,
        color: Y
    });

    walls.push({
        cx: canvas.width * 0.75,
        cy: canvas.height * 0.40,
        radius: 170,
        thickness: 30,
        start: 0.3 * Math.PI,
        end: 1.6 * Math.PI,
        color: Y
    });

    walls.push({
        cx: canvas.width * 0.22,
        cy: canvas.height * 0.72,
        radius: 160,
        thickness: 30,
        start: -0.3 * Math.PI,
        end: 1.1 * Math.PI,
        color: Y
    });

    walls.push({
        cx: canvas.width * 0.60,
        cy: canvas.height * 0.82,
        radius: 150,
        thickness: 30,
        start: -0.6 * Math.PI,
        end: 0.9 * Math.PI,
        color: Y
    });

    // Build collision segments from walls
    buildWallSegments();
}

// Convert curved walls into line segments for collision
function buildWallSegments() {
    wallSegments.length = 0;
    
    for (let w of walls) {
        const steps = 40; // More segments = smoother collision
        const angleStep = (w.end - w.start) / steps;
        const innerR = w.radius - w.thickness / 2;
        const outerR = w.radius + w.thickness / 2;
        
        for (let i = 0; i < steps; i++) {
            const a1 = w.start + i * angleStep;
            const a2 = w.start + (i + 1) * angleStep;
            
            // Inner arc segment
            wallSegments.push({
                x1: w.cx + Math.cos(a1) * innerR,
                y1: w.cy + Math.sin(a1) * innerR,
                x2: w.cx + Math.cos(a2) * innerR,
                y2: w.cy + Math.sin(a2) * innerR
            });
            
            // Outer arc segment
            wallSegments.push({
                x1: w.cx + Math.cos(a1) * outerR,
                y1: w.cy + Math.sin(a1) * outerR,
                x2: w.cx + Math.cos(a2) * outerR,
                y2: w.cy + Math.sin(a2) * outerR
            });
        }
        
        // End caps (close off the arc ends)
        const startAngle = w.start;
        const endAngle = w.end;
        
        // Start cap
        wallSegments.push({
            x1: w.cx + Math.cos(startAngle) * innerR,
            y1: w.cy + Math.sin(startAngle) * innerR,
            x2: w.cx + Math.cos(startAngle) * outerR,
            y2: w.cy + Math.sin(startAngle) * outerR
        });
        
        // End cap
        wallSegments.push({
            x1: w.cx + Math.cos(endAngle) * innerR,
            y1: w.cy + Math.sin(endAngle) * innerR,
            x2: w.cx + Math.cos(endAngle) * outerR,
            y2: w.cy + Math.sin(endAngle) * outerR
        });
    }
}

createWalls();

// ===============================
// COLLISION HELPER: Point to line segment distance
// ===============================
function pointToSegmentDistance(px, py, x1, y1, x2, y2) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    const lenSq = dx * dx + dy * dy;
    
    if (lenSq === 0) return Math.hypot(px - x1, py - y1);
    
    let t = ((px - x1) * dx + (py - y1) * dy) / lenSq;
    t = Math.max(0, Math.min(1, t));
    
    const nearX = x1 + t * dx;
    const nearY = y1 + t * dy;
    
    return {
        dist: Math.hypot(px - nearX, py - nearY),
        nearX,
        nearY
    };
}

// ===============================
// FOOD
// ===============================
function spawnFoodPile(x, y, count = 25) {
    for (let i = 0; i < count; i++) {
        foods.push({
            x: x + (Math.random() * 30 - 15),
            y: y + (Math.random() * 30 - 15),
            size: 3 + Math.random() * 1.5,
            color: "#f5f5f5"
        });
    }
}

spawnFoodPile(canvas.width * 0.15, canvas.height * 0.25);
spawnFoodPile(canvas.width * 0.78, canvas.height * 0.55);
spawnFoodPile(canvas.width * 0.45, canvas.height * 0.85);

canvas.addEventListener("click", e => {
    spawnFoodPile(e.clientX, e.clientY, 20);
});

// ===============================
// ANT CLASS
// ===============================
class Ant {
    constructor() {
        this.x = canvas.width / 2;
        this.y = canvas.height / 2;
        this.angle = Math.random() * Math.PI * 2;
        this.speed = 1.6;
        this.hasFood = false;
        this.foodPiece = null;
        this.radius = 4; // Ant collision radius
    }

    update() {
        if (this.hasFood) this.returnToNest();
        else this.scanForFood();

        // Store previous position
        const prevX = this.x;
        const prevY = this.y;

        this.move();
        this.wrap();
        
        // Check wall collision and resolve
        this.wallCollision(prevX, prevY);

        if (!this.hasFood) this.pickFood();
        else this.dropFood();

        this.followPheromone();
        this.dropPheromone();
    }

    move() {
        this.x += Math.cos(this.angle) * this.speed;
        this.y += Math.sin(this.angle) * this.speed;
    }

    wrap() {
        if (this.x < 0) this.x = canvas.width;
        if (this.x > canvas.width) this.x = 0;
        if (this.y < 0) this.y = canvas.height;
        if (this.y > canvas.height) this.y = 0;
    }

    // ======================================================
    // NEW WALL COLLISION - segment based
    // ======================================================
    wallCollision(prevX, prevY) {
        const collisionDist = this.radius + 2;
        
        for (let seg of wallSegments) {
            const result = pointToSegmentDistance(
                this.x, this.y,
                seg.x1, seg.y1, seg.x2, seg.y2
            );
            
            if (result.dist < collisionDist) {
                // Push ant away from the segment
                const pushDist = collisionDist - result.dist + 1;
                const dx = this.x - result.nearX;
                const dy = this.y - result.nearY;
                const len = Math.hypot(dx, dy) || 1;
                
                this.x += (dx / len) * pushDist;
                this.y += (dy / len) * pushDist;
                
                // Reflect angle off the wall
                const segDx = seg.x2 - seg.x1;
                const segDy = seg.y2 - seg.y1;
                const wallAngle = Math.atan2(segDy, segDx);
                
                // Reflect: new angle = 2 * wallAngle - old angle
                this.angle = 2 * wallAngle - this.angle + (Math.random() - 0.5) * 0.3;
            }
        }
    }

    scanForFood() {
        let best = null, dist2 = 999999;
        for (let f of foods) {
            const dx = f.x - this.x;
            const dy = f.y - this.y;
            const d = dx * dx + dy * dy;
            if (d < 80 * 80 && d < dist2) {
                dist2 = d;
                best = f;
            }
        }
        if (best) this.angle = Math.atan2(best.y - this.y, best.x - this.x);
    }

    pickFood() {
        for (let f of foods) {
            const dx = f.x - this.x;
            const dy = f.y - this.y;
            if (dx * dx + dy * dy < 10 * 10) {
                this.hasFood = true;
                this.foodPiece = f;
                foods.splice(foods.indexOf(f), 1);
                return;
            }
        }
    }

    returnToNest() {
        this.angle = Math.atan2(canvas.height / 2 - this.y, canvas.width / 2 - this.x);
    }

    dropFood() {
        const dx = this.x - canvas.width / 2;
        const dy = this.y - canvas.height / 2;
        if (dx * dx + dy * dy < 20 * 20) {
            this.hasFood = false;
            this.foodPiece = null;
        }
    }

    followPheromone() {
        const ahead = this.sense(0);
        const left = this.sense(0.5);
        const right = this.sense(-0.5);

        if (left > ahead && left > right) this.angle += 0.25;
        else if (right > ahead && right > left) this.angle -= 0.25;
        else if (Math.random() < 0.02) this.angle += (Math.random() - 0.5) * 0.6;
    }

    sense(offset) {
        const sx = this.x + Math.cos(this.angle + offset) * 15;
        const sy = this.y + Math.sin(this.angle + offset) * 15;
        const cx = Math.floor(sx / gridSize);
        const cy = Math.floor(sy / gridSize);
        return (pheromone[cx] && pheromone[cx][cy]) || 0;
    }

    dropPheromone() {
        const cx = Math.floor(this.x / gridSize);
        const cy = Math.floor(this.y / gridSize);
        if (pheromone[cx] && pheromone[cx][cy] !== undefined)
            pheromone[cx][cy] += this.hasFood ? 3 : 0.4;
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);

        ctx.fillStyle = this.hasFood ? "#ff4500" : "#ff7b00";
        ctx.beginPath();
        ctx.ellipse(0, 0, 4, 3, 0, 0, Math.PI * 2);
        ctx.fill();

        if (this.foodPiece) {
            ctx.fillStyle = "#fff";
            ctx.beginPath();
            ctx.arc(-6, 0, 2, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.restore();
    }
}

// ===============================
// INIT ANTS
// ===============================
for (let i = 0; i < ANT_COUNT; i++) ants.push(new Ant());

// ===============================
// DRAW HELPERS
// ===============================
function drawFood(f) {
    ctx.beginPath();
    ctx.fillStyle = f.color;
    ctx.arc(f.x, f.y, f.size, 0, Math.PI * 2);
    ctx.fill();
}

function evaporate() {
    for (let x = 0; x < cols; x++)
        for (let y = 0; y < rows; y++)
            pheromone[x][y] *= 0.96;
}

function drawPhero() {
    for (let x = 0; x < cols; x++)
        for (let y = 0; y < rows; y++) {
            const p = pheromone[x][y];
            if (p > 0.3) {
                ctx.fillStyle = `rgba(255,120,20,${p / 40})`;
                ctx.fillRect(x * gridSize, y * gridSize, gridSize, gridSize);
            }
        }
}

function drawWalls() {
    walls.forEach(w => {
        ctx.save();
        ctx.beginPath();
        ctx.lineWidth = w.thickness;
        ctx.strokeStyle = w.color;
        ctx.lineCap = "round"; // Round end caps
        ctx.arc(w.cx, w.cy, w.radius, w.start, w.end);
        ctx.stroke();
        ctx.restore();
    });
}

// ===============================
// MAIN LOOP
// ===============================
function animate() {
    ctx.fillStyle = "rgba(0,0,0,0.25)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    evaporate();
    drawPhero();
    drawWalls();
    foods.forEach(drawFood);
    ants.forEach(a => { a.update(); a.draw(); });

    requestAnimationFrame(animate);
}

animate();

</script>
</body>
</html>




