<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Circular Vortex Leaf Fish</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #000;
  }
  canvas {
    display: block;
  }
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resize();
window.addEventListener("resize", resize);

const center = { x: canvas.width / 2, y: canvas.height / 2 };

// ---------------- FISH SETTINGS ----------------
const FISH_COUNT = 400;
const fish = [];

const BASE_SPEED = 1.6;
const VORTEX_STRENGTH = 1.1;
const INWARD_PULL = 0.38;
const NOISE = 0.18;

const MIN_RADIUS = 25;
const RING_MIN = 180;
const RING_MAX = Math.min(canvas.width, canvas.height) * 0.6;

// ---------------- FISH CLASS ----------------
class Fish {
  constructor() {
    this.spawn();
  }

  spawn() {
    const a = Math.random() * Math.PI * 2;
    const r = RING_MIN + Math.random() * (RING_MAX - RING_MIN);
    this.x = center.x + Math.cos(a) * r;
    this.y = center.y + Math.sin(a) * r;
    this.length = 10 + Math.random() * 10;
    this.speed = BASE_SPEED * (0.7 + Math.random() * 0.6);
    this.angle = a;
  }

  step() {
    const dx = center.x - this.x;
    const dy = center.y - this.y;
    const r = Math.sqrt(dx * dx + dy * dy) + 0.0001;

    // too close â†’ restart so vortex never collapses
    if (r < MIN_RADIUS) {
      this.spawn();
      return;
    }

    // inward radial pull
    const rx = dx / r;
    const ry = dy / r;

    // tangential movement (vortex swirl)
    const tx = -ry;
    const ty = rx;

    let vx = tx * VORTEX_STRENGTH * this.speed;
    let vy = ty * VORTEX_STRENGTH * this.speed;

    vx += rx * INWARD_PULL * this.speed;
    vy += ry * INWARD_PULL * this.speed;

    // random organic wobble
    vx += (Math.random() - 0.5) * NOISE;
    vy += (Math.random() - 0.5) * NOISE;

    this.x += vx;
    this.y += vy;

    // wrap outward
    if (
      this.x < -100 || this.x > canvas.width + 100 ||
      this.y < -100 || this.y > canvas.height + 100
    ) {
      this.spawn();
    }

    this.angle = Math.atan2(vy, vx);
  }

  draw(ctx) {
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.angle);

    const len = this.length;
    const w = len * 0.45; // leaf width

    // leaf-shaped fish
    ctx.beginPath();
    ctx.moveTo(-len * 0.5, 0);
    ctx.quadraticCurveTo(0, -w, len * 0.5, 0);
    ctx.quadraticCurveTo(0, w, -len * 0.5, 0);
    ctx.closePath();

    ctx.fillStyle = "rgba(255,255,255,0.93)";
    ctx.fill();

    ctx.restore();
  }
}

// create fish
for (let i = 0; i < FISH_COUNT; i++) fish.push(new Fish());

// ---------------- BLUE CIRCULAR WATER LINES ----------------
let time = 0;

function drawCircularWater() {
  const maxR = Math.min(canvas.width, canvas.height) * 0.65;

  for (let r = 40; r < maxR; r += 38) {
    const angStart = time * 0.8 + r * 0.01;
    const angEnd = angStart + Math.PI * 0.7;

    ctx.beginPath();
    ctx.arc(center.x, center.y, r, angStart, angEnd);
    ctx.strokeStyle = "rgba(0, 140, 255, 0.32)";
    ctx.lineWidth = 2;
    ctx.stroke();
  }
}

// ---------------- MAIN LOOP ----------------
function animate(ts) {
  time = ts * 0.001;

  // smooth fading trail
  ctx.fillStyle = "rgba(0,0,0,0.32)";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // circular blue water ripples
  drawCircularWater();

  // fish behavior
  fish.forEach(f => {
    f.step();
    f.draw(ctx);
  });

  requestAnimationFrame(animate);
}

requestAnimationFrame(animate);
</script>
</body>
</html>





