<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Root Growth with Worms and Insects</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #0a0a0a;
    }
    canvas { display: block; }
  </style>
</head>
<body>
<script>
  let roots = [];
  let worms = [];
  let insects = [];
  let soil;
  
  function setup() {
    createCanvas(windowWidth, windowHeight);
    soil = createGraphics(width, height);
    soil.background(15, 35, 20); // dark green
    strokeCap(ROUND);
    
    // üå± Start single root from top center
    roots.push(new Root(width / 2, 0, PI / 2, 0));
    
    // ü™± Create earthworms (realistic segments)
    for (let i = 0; i < 8; i++) {
      worms.push(new Worm(random(width * 0.3, width * 0.7), random(height * 0.3, height * 0.8)));
    }
    
    // üêú Create insects (small beetles/bugs)
    for (let i = 0; i < 15; i++) {
      insects.push(new Insect(random(width * 0.3, width * 0.7), random(height * 0.2, height * 0.9)));
    }
  }
  
  function draw() {
    image(soil, 0, 0);
    
    // üå± Draw roots on soil layer
    for (let i = roots.length - 1; i >= 0; i--) {
      roots[i].grow(soil);
      if (!roots[i].alive) roots.splice(i, 1);
    }
    
    // ü™± Draw worms
    for (let w of worms) {
      w.move();
      w.display();
    }
    
    // üêú Draw insects
    for (let ins of insects) {
      ins.move();
      ins.display();
    }
  }
  
  // üå± ROOT CLASS
  class Root {
    constructor(x, y, angle, depth) {
      this.x = x;
      this.y = y;
      this.angle = angle;
      this.depth = depth;
      this.life = int(random(100, 250));
      this.alive = true;
    }
    
    grow(layer) {
      if (!this.alive) return;
      
      let step = random(2, 6);
      this.angle += random(-0.15, 0.15);
      
      let newX = this.x + cos(this.angle) * step;
      let newY = this.y + sin(this.angle) * step;
      
      // Draw on soil layer
      layer.stroke(255, 255, 255, 220); // white roots
      let w = map(this.depth, 0, 6, 6, 1.5);
      layer.strokeWeight(max(1, w));
      layer.line(this.x, this.y, newX, newY);
      
      this.x = newX;
      this.y = newY;
      this.life--;
      
      // Branch occasionally
      if (random() < 0.04 && this.depth < 6) {
        let branchAngle = this.angle + random(-0.9, 0.9);
        roots.push(new Root(this.x, this.y, branchAngle, this.depth + 1));
      }
      
      if (this.life <= 0 || this.y > height + 10 || this.x < -10 || this.x > width + 10) {
        this.alive = false;
      }
    }
  }
  
  // ü™± REALISTIC EARTHWORM (segmented body, fixed length)
  class Worm {
    constructor(x, y) {
      this.segments = [];
      this.segmentCount = 15; // fixed segment count
      this.segmentLength = 4;
      
      // Initialize segments
      for (let i = 0; i < this.segmentCount; i++) {
        this.segments.push({x: x, y: y});
      }
      
      this.angle = random(TWO_PI);
      this.speed = random(0.3, 0.7);
      this.wiggle = 0;
      this.boundaryBuffer = 100;
    }
    
    move() {
      this.wiggle += 0.1;
      this.angle += sin(this.wiggle) * 0.05 + random(-0.08, 0.08);
      
      // Move head
      let newX = this.segments[0].x + cos(this.angle) * this.speed;
      let newY = this.segments[0].y + sin(this.angle) * this.speed;
      
      // Boundary containment (stay in root zone)
      let centerX = width / 2;
      let centerY = height / 2;
      let maxDist = min(width, height) * 0.35;
      
      let distFromCenter = dist(newX, newY, centerX, centerY);
      if (distFromCenter > maxDist) {
        // Turn toward center
        this.angle = atan2(centerY - newY, centerX - newX) + random(-0.3, 0.3);
      }
      
      // Keep in vertical zone
      if (newY < height * 0.2) this.angle = PI / 2; // turn down
      if (newY > height * 0.95) this.angle = -PI / 2; // turn up
      
      // Update segments (follow the leader)
      this.segments.unshift({x: newX, y: newY});
      if (this.segments.length > this.segmentCount) {
        this.segments.pop();
      }
    }
    
    display() {
      noFill();
      stroke(255, 150, 180, 220); // pink earthworm
      strokeWeight(4);
      
      beginShape();
      for (let i = 0; i < this.segments.length; i++) {
        let seg = this.segments[i];
        curveVertex(seg.x, seg.y);
      }
      endShape();
      
      // Draw segments for texture
      stroke(255, 120, 160, 180);
      strokeWeight(1);
      for (let i = 0; i < this.segments.length - 1; i += 2) {
        let seg = this.segments[i];
        point(seg.x, seg.y);
      }
    }
  }
  
  // üêú INSECT (small beetle with legs)
  class Insect {
    constructor(x, y) {
      this.x = x;
      this.y = y;
      this.vx = random(-0.5, 0.5);
      this.vy = random(-0.5, 0.5);
      this.size = random(3, 6);
      this.legPhase = random(TWO_PI);
      this.boundaryBuffer = 100;
    }
    
    move() {
      // Random walk
      this.vx += random(-0.1, 0.1);
      this.vy += random(-0.1, 0.1);
      
      // Limit speed
      this.vx = constrain(this.vx, -1, 1);
      this.vy = constrain(this.vy, -1, 1);
      
      this.x += this.vx;
      this.y += this.vy;
      
      // Boundary containment (stay in root zone)
      let centerX = width / 2;
      let centerY = height / 2;
      let maxDist = min(width, height) * 0.4;
      
      let distFromCenter = dist(this.x, this.y, centerX, centerY);
      if (distFromCenter > maxDist) {
        // Push back toward center
        this.vx += (centerX - this.x) * 0.01;
        this.vy += (centerY - this.y) * 0.01;
      }
      
      // Vertical boundaries
      if (this.y < height * 0.15) this.vy = abs(this.vy);
      if (this.y > height * 0.95) this.vy = -abs(this.vy);
      
      this.legPhase += 0.2;
    }
    
    display() {
      push();
      translate(this.x, this.y);
      
      // Body
      noStroke();
      fill(20, 20, 20); // black bugs
      ellipse(0, 0, this.size, this.size * 1.3);
      ellipse(0, -this.size * 0.4, this.size * 0.7, this.size * 0.8);
      
      // Legs (animated)
      stroke(15, 15, 15);
      strokeWeight(0.5);
      let legOffset = sin(this.legPhase) * 2;
      for (let i = -1; i <= 1; i += 2) {
        line(0, 0, i * this.size * 0.8, legOffset);
        line(0, this.size * 0.3, i * this.size * 0.7, this.size * 0.5 + legOffset);
        line(0, -this.size * 0.3, i * this.size * 0.6, -this.size * 0.5 - legOffset);
      }
      
      pop();
    }
  }
  
  function windowResized() {
    resizeCanvas(windowWidth, windowHeight);
    soil = createGraphics(width, height);
    soil.background(15, 35, 20);
  }
</script>
</body>
</html>




